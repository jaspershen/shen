---
title: ggplot2-cookbook
author: Xiaotao Shen
date: '2019-10-25'
slug: ggplot2-cookbook
categories:
  - R
tags:
  - Blog
image:
  caption: ''
  focal_point: ''
output:
  blogdown::html_page:
    toc: true
    number_sections: true
---

## 绘图基础(plot basics)

所有的ggplot2图形都开始于`ggplot()`函数的调用.给其提供数据,以及美学映射(aesthethic mappings)(使用`aes()`函数).然后添加图层(layers), 度量系统(scales), 坐标系(coords)以及分面(facets).添加的每个对象,都是在前一行末尾使用符号`+`.如果需要将一个ggplot2图像保存在本地,使用`ggsave()`函数.

### `ggplot()` 创建一个新的ggplot图片

`ggplot()`函数是用来启动初始化一个ggplot2对象的.It can be used to declare the input data frame for a graphic and to specify the set of plot aesthetics intended to be common throughout all subsequent layers unless specifically overridden.

```
ggplot(data = NULL, mapping = aes(), ...,
  environment = parent.frame())
Arguments
```

#### 参数

* **data** 用于绘图的数据.如果数据格式不是`data.frame`,会默认使用`fortity()`函数转换为`data.frame`格式.如果在该函数中不提供data,则在后面添加的每一个图层,都需要提供data.

* **mapping** 用于美学图层映射的参数.如果在这里不提供,则后面添加的每个图层,都需要提供.

* **...** 其他可用于该函数的参数.

* **environment** 该参数已经淘汰了.

#### 细节

`ggplot()`用来初始化ggplot2图形对象.经常后面需要通过`+`来添加其他的对象.一般有三种方法调用该函数:

* `ggplot(df, aes(x, y, other aesthetics))`

* `ggplot(df)`

* `ggplot2`

如果后面的所有图层使用的都是同一套数据以及美学映射,则推荐使用第一种用法.如果后面图层使用数据一致,但是美学映射不同,则推荐使用第二种方法.如果每一个图层使用的数据和美学映射都不相同,则使用第三种方法,一般用来构建比较复杂的图形.

#### 例子

```{r}
library(ggplot2)
# 产生随机数据,然后计算平均值和标准差
df <- data.frame(
  gp = factor(rep(letters[1:3], each = 10)),
  y = rnorm(30)
)
ds <- do.call(rbind, lapply(split(df, df$gp), function(d) {
  data.frame(mean = mean(d$y), sd = sd(d$y), gp = d$gp)
}))

ggplot(df, aes(gp, y)) +
  geom_point() +
  geom_point(data = ds, aes(y = mean), colour = 'red', size = 3)

#注意,第一个geom_point图层使用的是ggplot中的数据和美学映射.而第二个geom_point
#图层中使用的则是不同的数据和美学映射.

# 而下面这幅图,第一个geonm_point图层因为没有提供data,因此使用的是ggplot()中的data,
#而美学映射则是自己定义的.

ggplot(df) +
  geom_point(aes(gp, y)) +
  geom_point(data = ds, aes(gp, mean), colour = 'red', size = 3)

# 另外一个选择则是完全不在ggplot中定义数据和美学映射,而是在每一个图层中分别定义.
# 当你要画复杂图形的时候,这种方法就会显示的非常清晰和明了.
ggplot() +
  geom_point(data = df, aes(gp, y)) +
  geom_point(data = ds, aes(gp, mean), colour = 'red', size = 3) +
  geom_errorbar(
    data = ds,
    aes(gp, mean, ymin = mean - sd, ymax = mean + sd),
    colour = 'red',
    width = 0.4
  )

```

### `aes()` 创建美学映射

美学映射指的是数据中的变量如何映射到图形的视觉特性上(也就是美学aesthetics).美学映射可以在`ggplot()`函数以及每一个单独的图层中进行设置.

`aes(x, y, ...)`

#### 参数

* **x, y, ...** 将变量映射到图形的视觉特性的名字.x和y分别指x轴和y轴.通常他们可以省略不写.但是其他的,如颜色(colour/color),填充颜色(fill),大小(size)等则必须写明参数名字.

#### 细节

注意的是,在ggplot2种,对于视觉特征的名字进行了规范化,因此和R base绘图函数种的并不相同,比如从`pch`改为`shape`,从`cex`改为`size`.

#### 例子

```{r}
aes(x = mpg, y = wt)
#> Aesthetic mapping: 
#> * `x` -> `mpg`
#> * `y` -> `wt`
aes(mpg, wt)
#> Aesthetic mapping: 
#> * `x` -> `mpg`
#> * `y` -> `wt`

# You can also map aesthetics to functions of variables
aes(x = mpg ^ 2, y = wt / cyl)
#> Aesthetic mapping: 
#> * `x` -> `mpg^2`
#> * `y` -> `wt/cyl`

# Or to constants
aes(x = 1, colour = "smooth")
#> Aesthetic mapping: 
#> * `x`      -> 1
#> * `colour` -> "smooth"

# Aesthetic names are automatically standardised
aes(col = x)
#> Aesthetic mapping: 
#> * `colour` -> `x`
aes(fg = x)
#> Aesthetic mapping: 
#> * `colour` -> `x`
aes(color = x)
#> Aesthetic mapping: 
#> * `colour` -> `x`
aes(colour = x)
#> Aesthetic mapping: 
#> * `colour` -> `x`

# aes() is passed to either ggplot() or specific layer. Aesthetics supplied
# to ggplot() are used as defaults for every layer.
ggplot(mpg, aes(displ, hwy)) + geom_point()

ggplot(mpg) + geom_point(aes(displ, hwy))

# Tidy evaluation ----------------------------------------------------
# aes() automatically quotes all its arguments, so you need to use tidy
# evaluation to create wrappers around ggplot2 pipelines. The
# simplest case occurs when your wrapper takes dots:
scatter_by <- function(data, ...) {
  ggplot(data) + geom_point(aes(...))
}
scatter_by(mtcars, disp, drat)

# If your wrapper has a more specific interface with named arguments,
# you need "enquote and unquote":
scatter_by <- function(data, x, y) {
  x <- enquo(x)
  y <- enquo(y)

  ggplot(data) + geom_point(aes(!!x, !!y))
}
scatter_by(mtcars, disp, drat)

# Note that users of your wrapper can use their own functions in the
# quoted expressions and all will resolve as it should!
cut3 <- function(x) cut_number(x, 3)
scatter_by(mtcars, cut3(disp), drat)
```

### `ggsave()`保存`ggplot2`图片对象

`ggsave()`默认会保存当前最后一幅`ggplot2`图片.如果不设置尺寸,则使用当前设备尺寸.

```
ggsave(filename, plot = last_plot(), device = NULL, path = NULL,
  scale = 1, width = NA, height = NA, units = c("in", "cm", "mm"),
  dpi = 300, limitsize = TRUE, ...)
```

#### 参数

* **filename** 要保存的图片的名字,注意不包括后缀名.

* **plot** 要保存的`ggplot2`图片.

* **device** 要保存的图片的类型.包括以下:"eps", "ps", "tex" (pictex), "pdf", "jpeg", "tiff", "png", "bmp", "svg" or "wmf" (windows only).

* **path** 图片所要保存的路径.

* **scale** Multiplicative scaling factor.暂时不知道什么意思?

* **width, height, units** 要保存图片的宽和高,以及其单位.单位包括:"in"(英寸), "cm", or "mm".

* **dpi** 图片分辨率.一般是数字.也可以使用文字符:"retina" (320), "print" (300), or "screen" (72).

* **limitsize** 如果设置为TRUE,则`ggsave`不会保存尺寸大于50×50 inch的图片.

* **...** 其他可以用于图形设备(graphics device function)的参数.

## 图层(Layer):几何对象(geoms)

一个图层包括了数据(data),美学映射(aesthetic mapping),几何对象(geometric object),统计转换(statistical transformation),以及位置调整(position adjustment).一般来说,应该使用`geom_xxx()`函数来创建图层.必要情况下,需要手动设置去覆盖默认的位置和统计转换.

### 直线`geom_abline`,`geom_hline`和`geom_vline`

这三个函数(几何对象)分别用来画对角线,水平和垂直直线.

```
geom_abline(mapping = NULL, data = NULL, ..., slope, intercept,
  na.rm = FALSE, show.legend = NA)

geom_hline(mapping = NULL, data = NULL, ..., yintercept,
  na.rm = FALSE, show.legend = NA)

geom_vline(mapping = NULL, data = NULL, ..., xintercept,
  na.rm = FALSE, show.legend = NA)
```

#### 参数

* **mapping** 美学映射,使用`aes()`函数设置.

* **data** 用于创建该图层的数据.有三种选择:     1)如果设置为`NULL`,也是默认设置.则该数据继承自`ggplot()`函数中的数据.2)一个`data.frame`,或者其他的对象,如`tibble`,这将会覆盖`ggplot()`中的数据.3)也可以是一个`function()`,但是该function最后返回的对象应该是`data.frame`.`function`可以使用`formula`格式进行创建,如:`head(.x, 10)`

* **...** 其他的可以传入`layer()`的参数.一般是美学对象,如`colour = "red"`或者`size = 3`.也可以是一些一些能够传入到和`geom_`配对的geom/stat的参数.

* **na.rm** 默认为`FALSE`, missing value会被去除掉,但是会给出`warning`,如果设置为`TRUE`,missing value也会被去除掉,但是不会给`warning`.

* **show.legend** 该图层是否要显示在legend上.默认为`NA`,则该图层中所有的映射到图形属性的变量都会显示在legend中.`FALSE`则永远不显示,`TRUE`则永远显示.如果该图形有多个变量映射到不同的图形属性,则可以将其设置为一个vector,分别控制不同的变量是否显示.

* **xintercept/yintercept/slope/intercept** 控制直线的位置参数.如果这些设置了,则`data`,`mapping`和`show.legend`则会被覆盖掉.

#### 细节

这些几何对象和其他的几何对象稍微有些不同.可以通过两种方法提供参数:1)给layer函数提供参数,或者2)通过美学对象提供参数.如果你使用参数,例如`geom_abline(intercept = 0, slope = 1)`,然后几何对象(`geom_`)会创建一个新的data frame,这个data rame只包括了你所提供的数据.这意味着在所有的分面中,直线都是相同的.如果你想在不同的分面中,直线不相同,你需要自己创建一个data frame,然后再美学映射(aesthetics)中设置.

与其他的几何对象不同,这些几何对象不会从`ggplot`中继承data.他们也不会影响到x和y的scale.

#### 美学映射(Aesthetics)

这三个几何对象(geom)其实都是使用`geom_line()`函数来画直线的,因此他们都支持`geom_line()`的美学参数,如`alpha`,`colour`,`linetype`和`size`.对于每个几何对象都有,都有单独的参数用来控制直线的位置:

* `geom_vline`:`xintercept`.

* `geom_hline`:`yintercept`.

* `geom_vline`:`slope`(斜率)和`intercept`(截距).

#### 例子

```{r}
library(ggplot2)
p <- 
  ggplot(mtcars, aes(wt, mpg)) + 
  geom_point()

# 添加垂直直线
p + 
  geom_vline(xintercept = 5)
p + 
  geom_vline(xintercept = 1:5)

# 添加水平直线
p + 
  geom_hline(yintercept = 20)

# 添加对角线,默认斜率为1
p + 
  geom_abline(intercept = 20)

# 计算直线回归的斜率和截距
coef(lm(mpg ~ wt, data = mtcars))
p + 
  geom_abline(intercept = 37, slope = -5)

# 但是使用geom_smooth更加简单h:
p + 
  geom_smooth(method = "lm", se = FALSE)

# 如果想要再不同分面显示不同的直线,则使用美学对象,也就是需要自己创建
p <- ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  facet_wrap(~ cyl)

mean_wt <- 
  data.frame(cyl = c(4, 6, 8), wt = c(2.28, 3.11, 4.00))
mean_wt
p + 
  geom_hline(mapping = aes(x = cyl, yintercept = wt), 
             data = mean_wt)
##如果不使用美学对象,则在每一个分面上都是一样的
p +
  geom_hline(yintercept = mean_wt$wt)

# 控制其他美学对象
ggplot(mtcars, aes(mpg, wt, colour = wt)) +
  geom_point() +
  geom_hline(aes(yintercept = wt, colour = wt), mean_wt) +
  facet_wrap(~ cyl)
```










